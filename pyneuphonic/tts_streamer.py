import asyncio
import logging
import os

import pyaudio
import threading
import queue
import nest_asyncio
import time
import ssl
import certifi

import websockets
from websockets import WebSocketClientProtocol
from typing import AsyncGenerator

nest_asyncio.apply()


class TTSStreamer:
    def __init__(self, API_TOKEN=None, WEBSOCKET_URL='wss://neuphonic.us/speak/en'):
        if API_TOKEN is None:
            API_TOKEN = os.getenv('NEUPHONIC_API_TOKEN')

            if API_TOKEN is None:
                raise EnvironmentError(
                    'NEUPHONIC_API_TOKEN has not been passed in and is not set in the environment.'
                )

        # Create the websocket_url from the given api_token
        self.api_token = API_TOKEN
        self.websocket_url = f'{WEBSOCKET_URL}/{API_TOKEN}'

        # A FIFO (first-in-first-out) list of audio received from the websocket API
        self.audio_queue = queue.Queue()

        # An "event" to indicate that the current stream of text has been played
        self.end_of_audio = asyncio.Event()

        self.audio_latency = 0
        self.first_byte_received = False
        self.send_time = None
        self.first_token_time = None
        self.text_queue = asyncio.Queue()

    def play_audio(self):
        """
        Hooks into the self.audio_queue object (which stores the bytes sent back from the websocket api)
        and plays the audio.
        """
        audio_player = pyaudio.PyAudio()  # create the pyaudio audio player

        stream = audio_player.open(
            format=pyaudio.paInt16, channels=1, rate=22000, output=True
        )

        buffer = b''

        while True:  # keep looping until audio is finished being generated by websocket
            try:
                audio_data = self.audio_queue.get(
                    timeout=1
                )  # get the next piece of audio byte data

                if audio_data is None:
                    break

                buffer += audio_data

                # play a small chunk at a time
                while len(buffer) >= 4096:
                    stream.write(buffer[:4096])
                    buffer = buffer[4096:]
            except queue.Empty:
                if self.end_of_audio.is_set() and self.audio_queue.empty():
                    break

        # play the rest of the audio
        if len(buffer) > 0:
            stream.write(buffer)

        # clean up everything
        stream.stop_stream()
        stream.close()
        audio_player.terminate()

    async def message_handler(self, websocket: WebSocketClientProtocol):
        """
        Handles messages received from the websocket API.

        Parameters
        ----------
        websocket : WebSocketClientProtocol
            The instance of WebSocketClientProtocol returned from websockets.connect(...).
            This should be an active connection to the Neuphonic websocket api and it will yield audio
        """
        async for message in websocket:  # as each message is received in the websocket
            if isinstance(message, bytes):
                if not self.first_byte_received:
                    # Record the latency if this is the first message
                    self.first_byte_received = True
                    self.audio_latency = time.time() - self.first_token_time
                    logging.info(f'TTS latency: {self.audio_latency:.3f} seconds')

                self.audio_queue.put(
                    message
                )  # put the received audio into the audio queue to be handled
            elif '[EOS]' in message:
                break

        self.end_of_audio.set()  # Set this event to trigger the fact that all the audio has been received

    async def send_text(
        self, websocket: WebSocketClientProtocol, text_generator: AsyncGenerator
    ):
        """
        Sends text to the websocket API to convert the text to speech.

        Parameters
        ----------
        websocket : WebSocketClientProtocol
            The instance of WebSocketClientProtocol returned from websockets.connect(...), connected to
            the Neuphonic websocket.
        text_generator : AsyncGenerator
            An async text generator that yields strings, which compose the text to convert to speech.
        """
        self.send_time = time.time()
        first_token = True

        async for text in text_generator:
            if first_token:
                self.first_token_time = time.time()
                first_token = False
                logging.info(
                    f'LLM latency: {self.first_token_time - self.send_time:.3f} seconds'
                )

            await websocket.send(text)  # send the token to the websocket
            await self.text_queue.put(text)  # also save the token into the text_queue

        # Once all the text has been sent, send the end-of-statement indicator [EOS] to terminate generation
        await websocket.send('[EOS]')
        await self.text_queue.put('[EOS]')

    async def _log_output(self):
        output = ['\033[32mResponse :: [']  # Start the response
        while True:
            text = await self.text_queue.get()
            if text == '[EOS]':
                output.append(']\033[0m')  # Close the bracket and reset color
                logging.info(''.join(output))
                break
            output.append(f'{text}')  # Add each chunk to output list

    async def stream(self, text_generator: AsyncGenerator):
        """
        Entry point for text-to-speech.

        This class will take a text generator object that yields strings, and convert these strings to audio piece by
        piece using the websocket API. It uses other class methods to play the audio and handle downstream tasks.

        Parameters
        ----------
        text_generator : Generator[str]
            The text generator object to yield strings from.

        """
        self.audio_queue = queue.Queue()  # Create a new audio queue
        self.end_of_audio.clear()  # clear Event - i.e., indicate "audio has not finished playing"
        self.first_byte_received = False

        # Start the audio thread, this is run asynchronously so that it doesn't block the rest of the program
        audio_thread = threading.Thread(target=self.play_audio)
        audio_thread.start()  # start processing incoming audio, this is done in the play_audio function

        ssl_context = ssl.create_default_context(cafile=certifi.where())

        try:
            async with websockets.connect(self.websocket_url, ssl=ssl_context) as ws:
                receive_task = asyncio.create_task(self.message_handler(ws))
                send_task = asyncio.create_task(self.send_text(ws, text_generator))
                print_task = asyncio.create_task(self._log_output())
                await asyncio.wait_for(
                    asyncio.gather(send_task, receive_task, print_task), timeout=60
                )
        except Exception as e:
            print(f'Error in TTS process: {e}')
        finally:
            self.end_of_audio.set()
            self.audio_queue.put(None)
            audio_thread.join()
